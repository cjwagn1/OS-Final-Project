{"version":3,"sources":["utils/Algorithms.ts","components/common/Visualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Process","name","arrival","total","arrivalTime","totalCPUTime","remainingCPUTime","turnaroundTime","startTime","endTime","line","processCount","color","this","gridData","ProcessGrid","styled","div","props","maxGridTime","numOfProcesses","NumberGrid","algorithmGridData","counter","currentTimer","basicGridData","useState","algoTimedData","setAlgoTimedData","maxGridSize","useEffect","i","oldArray","length","clearInterval","forEach","process","Object","entries","key","value","Array","map","e","style","border","borderRadius","gridColumn","gridRow","OSApp","VisualizerGroup","AlgoButton","button","ArrivalProcess","CPUTimeProcess","NewProcessInputs","InputGroup","AlgorithmButtons","SliderGroup","App","newProcess","algoData","setAlgoData","currentProcesses","setCurrentProcesses","setCounter","setArrivalTime","cpuTime","setCPUTime","timeQuantum","setTimeQuantum","delay","setDelay","isModalVisible","setIsModalVisible","timer","useRef","instantTimer","setInstantTimerCounter","current","setInterval","v","algoButtonHandler","event","preventDefault","currentTarget","textContent","args","runningProcess","FIFOGridData","complete","queue","running","runningProcessIterator","avgTurnaroundTime","push","assign","sort","p1","p2","console","log","shift","parseInt","replace","FIFO","SJFGridData","copyArgs","splice","SJF","SRTGridData","addedProcess","temp","SRT","RRGridData","RR","margin","backgroundColor","fontWeight","type","shape","size","onClick","ghost","oldProcesses","display","fontSize","onChange","defaultValue","min","max","disabled","Visualizer","title","visible","onOk","onCancel","width","okText","cancelText","Item","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.38500d17.chunk.js","sourcesContent":["// import React, { useState } from \"react\";\r\n\r\nexport class Process {\r\n  name: string;\r\n  arrivalTime: number;\r\n  totalCPUTime: number;\r\n  remainingCPUTime: number;\r\n  turnaroundTime: number;\r\n  startTime: number;\r\n  endTime: number;\r\n  line: number;\r\n  processCount: number;\r\n  color: string;\r\n\r\n  constructor(name: string, arrival: number, total: number) {\r\n    this.name = name;\r\n    this.arrivalTime = arrival;\r\n    this.totalCPUTime = total;\r\n    this.remainingCPUTime = total;\r\n    this.turnaroundTime = 0;\r\n    this.startTime = 0;\r\n    this.endTime = 0;\r\n    this.line = 0;\r\n    this.processCount = 0;\r\n    this.color = \"#2D3047\";\r\n  }\r\n}\r\n\r\nexport const p1 = new Process(\"p1\", 1, 6);\r\nexport const p2 = new Process(\"p2\", 2, 3);\r\nexport const p3 = new Process(\"p3\", 4, 2);\r\n\r\nexport const gridData = [p1, p2, p3];\r\n\r\n// export const FIFO = (...args: Process[]) => {\r\nexport const FIFO = (args: Process[]) => {\r\n  // complete is true when all processes are done\r\n\r\n  //carters untyped stuff\r\n  const FIFOGridData: any = [];\r\n  //-------\r\n\r\n  let complete: boolean = false;\r\n  let queue: Process[] = []; // shallow copy of args\r\n  let running: boolean = false;\r\n  let runningProcess!: Process;\r\n  let timer: number = 0;\r\n  let runningProcessIterator: number = 0;\r\n  let avgTurnaroundTime: number = 0;\r\n  const numOfProcesses: number = args.length;\r\n\r\n  // copy args to queue\r\n  args.forEach((process) => queue.push(Object.assign({}, process)));\r\n  // for (let i = 0; i < args.length; i++) {\r\n  //   FIFOGridData[args[i].name] = args[i];\r\n  // }\r\n\r\n  // sort queue based on arrival time:\r\n  //  - if 1 is returned, p2 is sorted before p1 (p2.arrival < p1.arrival)\r\n  //  - if -1 is returned, p1 is sorted before p2 (p1.arrival < p2.arrival)\r\n  queue.sort((p1, p2) => (p1.arrivalTime >= p2.arrivalTime ? 1 : -1));\r\n  // FIFOGridData.push(queue);\r\n  console.log(\"hello\", queue[0]);\r\n\r\n  // run until all processes are finished running\r\n  while (!complete) {\r\n    if (queue.length > 0) {\r\n      // take next process in queue and place it in running if no process is running,\r\n      // otherwise, wait until process is done\r\n      if (running === false) {\r\n        // a process can only run once it has arrived\r\n        if (queue[0].arrivalTime <= timer) {\r\n          running = true;\r\n          runningProcess = queue.shift()!;\r\n\r\n          FIFOGridData.push(runningProcess);\r\n          FIFOGridData[runningProcessIterator].processCount = numOfProcesses;\r\n          FIFOGridData[runningProcessIterator].line = parseInt(\r\n            FIFOGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n          );\r\n\r\n          console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n          FIFOGridData[runningProcessIterator].startTime = timer;\r\n        } else {\r\n          console.log(\"nothing is running at time %d\", timer);\r\n        }\r\n      }\r\n    } else {\r\n      console.log(\"queue is empty!\");\r\n    }\r\n\r\n    // increment \"timer\"\r\n    timer++;\r\n\r\n    // if no process is running, then don't touch the runningProcess (because\r\n    // there is no running process...)\r\n    if (running === true) {\r\n      // decrement remaining time of running process\r\n      runningProcess.remainingCPUTime--;\r\n      // console.log(runningProcess);\r\n\r\n      // do we need a new process?\r\n      if (runningProcess.remainingCPUTime === 0) {\r\n        running = false;\r\n        runningProcess.turnaroundTime = timer - runningProcess.arrivalTime;\r\n        console.log(\r\n          \"%s is done running at time %d\",\r\n          runningProcess.name,\r\n          timer\r\n        );\r\n        FIFOGridData[runningProcessIterator].endTime = timer;\r\n        avgTurnaroundTime += runningProcess.turnaroundTime;\r\n        runningProcessIterator++;\r\n\r\n        // FIFOGridData.push([runningProcess, timer]);\r\n        // FIFOGridData[runningProcess.name] = FIFOGridData[\r\n        //   runningProcess.name\r\n        // ].arrivalTime = timer;\r\n      }\r\n    }\r\n\r\n    if (queue.length === 0 && running === false) {\r\n      complete = true;\r\n      console.log(\"we're done!\");\r\n      console.log(\"Total Time: %d\", timer);\r\n\r\n      avgTurnaroundTime = avgTurnaroundTime / numOfProcesses;\r\n      console.log(\"Average Turnaround Time: %f\", avgTurnaroundTime);\r\n    }\r\n  }\r\n\r\n  console.log(\"DATA HERE:\", FIFOGridData);\r\n  return FIFOGridData;\r\n};\r\n\r\n// Shortest Job First:\r\n// With the SJF algorithm, there is no pre-emption. A process will run until\r\n// it is completely done, then the next process in the queue will run.\r\n// export const SJF = (...args: Process[]) => {\r\nexport const SJF = (args: Process[]) => {\r\n  // complete is true when all processes are done\r\n\r\n  //carters untyped stuff\r\n  const SJFGridData: any = [];\r\n  //-------\r\n\r\n  let complete: boolean = false;\r\n  let copyArgs: Process[] = [];\r\n  let queue: Process[] = [];\r\n  let running: boolean = false;\r\n  let runningProcess!: Process;\r\n  let timer: number = 0;\r\n  let avgTurnaroundTime: number = 0;\r\n  const numOfProcesses: number = args.length;\r\n  let runningProcessIterator: number = 0;\r\n  // copy args so we don't modify the processes (useful when multile algos\r\n  // are running with the same processes)\r\n  args.forEach((process) => copyArgs.push(Object.assign({}, process)));\r\n\r\n  // run until all processes are finished running\r\n  while (!complete) {\r\n    // if a process has arrived, add it to the queue and sort the queue\r\n    // based on total time\r\n    for (let i = 0; i < copyArgs.length; i++) {\r\n      if (timer === copyArgs[i].arrivalTime) {\r\n        // add to queue\r\n        queue.push(copyArgs[i]);\r\n\r\n        // remove from copyArgs list\r\n        copyArgs.splice(i, 1);\r\n\r\n        if (queue.length > 1) {\r\n          // re-order if necessary\r\n          //  - if 1 is returned, p2 is sorted before p1 (p2.total < p1.total)\r\n          //  - if -1 is returned, p1 is sorted before p2 (p1.total < p2.total)\r\n          queue.sort((p1, p2) => (p1.totalCPUTime >= p2.totalCPUTime ? 1 : -1));\r\n          // console.log(queue);\r\n        }\r\n      }\r\n    }\r\n\r\n    // take next process in queue and place it in running if no process is running,\r\n    // otherwise, wait until process is done\r\n    if (running === false) {\r\n      // can only run a process if it's ready\r\n      if (queue.length > 0) {\r\n        running = true;\r\n        runningProcess = queue.shift()!;\r\n        SJFGridData.push(runningProcess);\r\n        SJFGridData[runningProcessIterator].processCount = numOfProcesses;\r\n        SJFGridData[runningProcessIterator].line = parseInt(\r\n          SJFGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n        );\r\n\r\n        console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n\r\n        SJFGridData[runningProcessIterator].startTime = timer;\r\n      } else {\r\n        console.log(\"nothing is running at time %d\", timer);\r\n      }\r\n    }\r\n\r\n    // increment \"timer\"\r\n    timer++;\r\n\r\n    // if no process is running, then don't touch the runningProcess (because\r\n    // there is no running process...)\r\n    if (running === true) {\r\n      // decrement remaining time of running process\r\n      runningProcess.remainingCPUTime--;\r\n\r\n      // do we need a new process?\r\n      if (runningProcess.remainingCPUTime === 0) {\r\n        running = false;\r\n        runningProcess.turnaroundTime = timer - runningProcess.arrivalTime;\r\n        console.log(\r\n          \"%s is done running at time %d\",\r\n          runningProcess.name,\r\n          timer\r\n        );\r\n        SJFGridData[runningProcessIterator].endTime = timer;\r\n        avgTurnaroundTime += runningProcess.turnaroundTime;\r\n        runningProcessIterator++;\r\n        console.log(runningProcess);\r\n      }\r\n    }\r\n\r\n    // We are done if all of the following are true:\r\n    //  - ready queue is empty\r\n    //  - there isn't anything running\r\n    //  - there aren't any more processes waiting to arrive\r\n    if (queue.length === 0 && running === false && copyArgs.length === 0) {\r\n      complete = true;\r\n      console.log(\"we're done!\");\r\n      console.log(\"Total Time: %d\", timer);\r\n\r\n      avgTurnaroundTime = avgTurnaroundTime / numOfProcesses;\r\n      console.log(\"Average Turnaround Time: %f\", avgTurnaroundTime);\r\n    }\r\n  }\r\n  return SJFGridData;\r\n};\r\n\r\n// Shortest Remaining Time:\r\n// With the SRT algorithm, the cpu will check the queue when a new process\r\n// arrives or when a process completes. This is the pre-emptive version of\r\n// SJF so it can stop the currently executing process if a newly arrived\r\n// process requires less total CPU Time.\r\n// export const SRT = (...args: Process[]) => {\r\nexport const SRT = (args: Process[]) => {\r\n  // complete is true when all processes are done\r\n\r\n  //carters untyped stuff\r\n  const SRTGridData: any = [];\r\n  //-------\r\n\r\n  let complete: boolean = false;\r\n  let copyArgs: Process[] = [];\r\n  let queue: Process[] = [];\r\n  let running: boolean = false;\r\n  let runningProcess!: Process;\r\n  let timer: number = 0;\r\n  let avgTurnaroundTime: number = 0;\r\n  const numOfProcesses: number = args.length;\r\n  let addedProcess: boolean = false;\r\n  let temp: Process = new Process(\"temp\", 0, 0);\r\n  let runningProcessIterator: number = 0;\r\n\r\n  // copy args so we don't modify the processes (useful when multile algos\r\n  // are running with the same processes)\r\n  args.forEach((process) => copyArgs.push(Object.assign({}, process)));\r\n\r\n  // run until all processes are finished running\r\n  while (!complete) {\r\n    addedProcess = false;\r\n\r\n    // if a process has arrived, add it to the queue and sort the queue\r\n    // based on total time\r\n    for (let i = 0; i < copyArgs.length; i++) {\r\n      if (timer === copyArgs[i].arrivalTime) {\r\n        // add to queue\r\n        queue.push(copyArgs[i]);\r\n        addedProcess = true;\r\n\r\n        // remove from copyArgs list\r\n        copyArgs.splice(i, 1);\r\n\r\n        if (queue.length > 1) {\r\n          // re-order if necessary\r\n          //  - if 1 is returned, p2 is sorted before p1 (p2.total < p1.total)\r\n          //  - if -1 is returned, p1 is sorted before p2 (p1.total < p2.total)\r\n          queue.sort((p1, p2) => (p1.totalCPUTime >= p2.totalCPUTime ? 1 : -1));\r\n          // console.log(queue);\r\n        }\r\n      }\r\n    }\r\n\r\n    // if a process arrived, check to see if a different process should\r\n    // be running; i.e. check to see if there is a process whose remaining\r\n    // cpu time is less than the running process.\r\n    if (addedProcess && running === true) {\r\n      if (queue[0].remainingCPUTime < runningProcess.remainingCPUTime) {\r\n        // swap the current running process and the process first in queue\r\n        SRTGridData[runningProcessIterator].endTime = timer;\r\n\r\n        runningProcessIterator++;\r\n\r\n        temp.arrivalTime = runningProcess.arrivalTime;\r\n        temp.endTime = runningProcess.endTime;\r\n        temp.line = runningProcess.line;\r\n        temp.name = runningProcess.name;\r\n        temp.processCount = runningProcess.processCount;\r\n        temp.remainingCPUTime = runningProcess.remainingCPUTime;\r\n        temp.totalCPUTime = runningProcess.totalCPUTime;\r\n        temp.turnaroundTime = runningProcess.turnaroundTime;\r\n        temp.startTime = runningProcess.startTime;\r\n\r\n        console.log(\"%s is moved back to queue at time %d\", temp.name, timer);\r\n\r\n        runningProcess = queue.shift()!;\r\n        SRTGridData.push(runningProcess);\r\n        SRTGridData[runningProcessIterator].processCount = numOfProcesses;\r\n        SRTGridData[runningProcessIterator].line = parseInt(\r\n          SRTGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n        );\r\n        SRTGridData[runningProcessIterator].startTime = timer;\r\n        console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n        queue.push(temp);\r\n\r\n        // re-order queue if necessary\r\n        if (queue.length > 1) {\r\n          queue.sort((p1, p2) => (p1.totalCPUTime >= p2.totalCPUTime ? 1 : -1));\r\n        }\r\n      }\r\n    }\r\n\r\n    // take next process in queue and place it in running if no process is running,\r\n    // otherwise, wait until process is done\r\n    if (running === false) {\r\n      // can only run a process if it's ready\r\n      if (queue.length > 0) {\r\n        running = true;\r\n        runningProcess = queue.shift()!;\r\n        SRTGridData.push(runningProcess);\r\n        SRTGridData[runningProcessIterator].processCount = numOfProcesses;\r\n        SRTGridData[runningProcessIterator].line = parseInt(\r\n          SRTGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n        );\r\n        SRTGridData[runningProcessIterator].startTime = timer;\r\n        console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n      } else {\r\n        console.log(\"nothing is running at time %d\", timer);\r\n      }\r\n    }\r\n\r\n    // increment \"timer\"\r\n    timer++;\r\n\r\n    // if no process is running, then don't touch the runningProcess (because\r\n    // there is no running process...)\r\n    if (running === true) {\r\n      // decrement remaining time of running process\r\n      runningProcess.remainingCPUTime--;\r\n\r\n      // do we need a new process?\r\n      if (runningProcess.remainingCPUTime === 0) {\r\n        running = false;\r\n        runningProcess.turnaroundTime = timer - runningProcess.arrivalTime;\r\n        console.log(\r\n          \"%s is done running at time %d\",\r\n          runningProcess.name,\r\n          timer\r\n        );\r\n        avgTurnaroundTime += runningProcess.turnaroundTime;\r\n        SRTGridData[runningProcessIterator].endTime = timer;\r\n        runningProcessIterator++;\r\n        console.log(runningProcess);\r\n      }\r\n    }\r\n\r\n    // We are done if all of the following are true:\r\n    //  - ready queue is empty\r\n    //  - there isn't anything running\r\n    //  - there aren't any more processes waiting to arrive\r\n    if (queue.length === 0 && running === false && copyArgs.length === 0) {\r\n      complete = true;\r\n      console.log(\"we're done!\");\r\n      console.log(\"Total Time: %d\", timer);\r\n\r\n      avgTurnaroundTime = avgTurnaroundTime / numOfProcesses;\r\n      console.log(\"Average Turnaround Time: %f\", avgTurnaroundTime);\r\n    }\r\n  }\r\n\r\n  return SRTGridData;\r\n};\r\n\r\n// Round Robin:\r\n// With the RR algorithm, the running process is pre-emptively stopped\r\n// and swapped with a process in the ready queue. When a process is moved\r\n// from running to the queue, it will be placed at the bottom. Time quantum\r\n// can be changed by user\r\n// export const RR = (...args: Process[], timeQuantum: number) => {\r\nexport const RR = (timeQuantum: number, args: Process[]) => {\r\n  // complete is true when all processes are done\r\n  const RRGridData: any = [];\r\n\r\n  let complete: boolean = false;\r\n  let copyArgs: Process[] = [];\r\n  let queue: Process[] = [];\r\n  let running: boolean = false;\r\n  let runningProcess!: Process;\r\n  let timer: number = 0;\r\n  let counter: number = 0;\r\n  let avgTurnaroundTime: number = 0;\r\n  const numOfProcesses: number = args.length;\r\n  let temp: Process = new Process(\"temp\", 0, 0);\r\n  let runningProcessIterator: number = 0;\r\n\r\n  // copy args so we don't modify the processes (useful when multile algos\r\n  // are running with the same processes)\r\n  args.forEach((process) => copyArgs.push(Object.assign({}, process)));\r\n  console.log(\"time quantum:\", timeQuantum);\r\n  // run until all processes are finished running\r\n  while (!complete) {\r\n    // if a process has arrived, add it to the queue\r\n    for (let i = 0; i < copyArgs.length; i++) {\r\n      if (timer === copyArgs[i].arrivalTime) {\r\n        // add to queue\r\n        queue.push(copyArgs[i]);\r\n\r\n        // remove from copyArgs list\r\n        copyArgs.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // take next process in queue and place it in running if no process is running,\r\n    // otherwise, wait until process is done\r\n    if (running === false) {\r\n      // can only run a process if it's ready\r\n      if (queue.length > 0) {\r\n        running = true;\r\n        runningProcess = queue.shift()!;\r\n        console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n\r\n        RRGridData.push(runningProcess);\r\n        RRGridData[runningProcessIterator].processCount = numOfProcesses;\r\n        RRGridData[runningProcessIterator].line = parseInt(\r\n          RRGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n        );\r\n        RRGridData[runningProcessIterator].startTime = timer;\r\n      } else {\r\n        console.log(\"nothing is running at time %d\", timer);\r\n      }\r\n    }\r\n\r\n    // increment \"timer\"\r\n    timer++;\r\n\r\n    // if no process is running, then don't touch the runningProcess (because\r\n    // there is no running process...)\r\n    if (running === true) {\r\n      // decrement remaining time of running process\r\n      runningProcess.remainingCPUTime--;\r\n\r\n      // increment counter to determine when we reach a time quantum\r\n      counter++;\r\n\r\n      // is the process done?\r\n      if (runningProcess.remainingCPUTime === 0) {\r\n        running = false;\r\n        runningProcess.turnaroundTime = timer - runningProcess.arrivalTime;\r\n        console.log(\r\n          \"%s is done running at time %d\",\r\n          runningProcess.name,\r\n          timer\r\n        );\r\n\r\n        avgTurnaroundTime += runningProcess.turnaroundTime;\r\n\r\n        RRGridData[runningProcessIterator].endTime = timer;\r\n        runningProcessIterator++;\r\n        console.log(runningProcess);\r\n\r\n        // reset counter since the process is no longer running\r\n        counter = 0;\r\n      }\r\n\r\n      // swap the process if we've reached the next time quantum\r\n      if (counter === timeQuantum && queue.length > 0) {\r\n        RRGridData[runningProcessIterator].endTime = timer;\r\n\r\n        runningProcessIterator++;\r\n\r\n        temp.arrivalTime = runningProcess.arrivalTime;\r\n        temp.endTime = runningProcess.endTime;\r\n        temp.line = runningProcess.line;\r\n        temp.name = runningProcess.name;\r\n        temp.processCount = runningProcess.processCount;\r\n        temp.remainingCPUTime = runningProcess.remainingCPUTime;\r\n        temp.totalCPUTime = runningProcess.totalCPUTime;\r\n        temp.turnaroundTime = runningProcess.turnaroundTime;\r\n        temp.startTime = runningProcess.startTime;\r\n\r\n        console.log(\"%s is moved back to queue at time %d\", temp.name, timer);\r\n        runningProcess = queue.shift()!;\r\n\r\n        RRGridData.push(runningProcess);\r\n        RRGridData[runningProcessIterator].processCount = numOfProcesses;\r\n        RRGridData[runningProcessIterator].line = parseInt(\r\n          RRGridData[runningProcessIterator].name.replace(/\\D/g, \"\")\r\n        );\r\n        RRGridData[runningProcessIterator].startTime = timer;\r\n\r\n        console.log(\"%s is running at time %d\", runningProcess.name, timer);\r\n        queue.push(temp);\r\n      } else if (counter === timeQuantum && queue.length === 0) {\r\n        // reset counter so we make sure we keep checking for a swap\r\n        // at each time quantum\r\n        counter = 0;\r\n        console.log(\"nothing in queue to swap with\");\r\n      }\r\n    }\r\n\r\n    // We are done if all of the following are true:\r\n    //  - ready queue is empty\r\n    //  - there isn't anything running\r\n    //  - there aren't any more processes waiting to arrive\r\n    if (queue.length === 0 && running === false && copyArgs.length === 0) {\r\n      complete = true;\r\n      console.log(\"we're done!\");\r\n      console.log(\"Total Time: %d\", timer);\r\n\r\n      avgTurnaroundTime = avgTurnaroundTime / numOfProcesses;\r\n      console.log(\"Average Turnaround Time: %f\", avgTurnaroundTime);\r\n    }\r\n  }\r\n  return RRGridData;\r\n};\r\n","import React, { useEffect, useState } from \"react\";\r\nimport styled, { AnyStyledComponent } from \"styled-components\";\r\n\r\n// import ProcessItem from \"../../utils/types\";\r\n// import { motion } from \"framer-motion\";\r\n\r\ninterface IProcessGridProps {\r\n  numOfProcesses: number;\r\n  maxGridTime: number;\r\n}\r\n\r\ninterface IVisualizerProps {\r\n  algorithmGridData: { [key: string]: any };\r\n  counter: any;\r\n  currentTimer: any;\r\n  basicGridData: any;\r\n}\r\n\r\nconst ProcessGrid: AnyStyledComponent = styled.div`\r\n  display: grid;\r\n  margin: 4px;\r\n  grid-template-columns: repeat(\r\n    ${(props: IProcessGridProps) => props.maxGridTime},\r\n    1fr\r\n  );\r\n  grid-gap: ${(props: IProcessGridProps) => 1000 / props.maxGridTime}px;\r\n  grid-template-rows: repeat(\r\n    ${(props: IProcessGridProps) => props.numOfProcesses},\r\n    1fr\r\n  );\r\n\r\n  > div {\r\n    color: red;\r\n    text-align: center;\r\n  }\r\n`;\r\n\r\nconst NumberGrid: AnyStyledComponent = styled.div`\r\n  display: grid;\r\n  margin: 4px;\r\n  grid-template-columns: repeat(\r\n    ${(props: IProcessGridProps) => props.maxGridTime},\r\n    1fr\r\n  );\r\n  grid-gap: ${(props: IProcessGridProps) => 1000 / props.maxGridTime}px;\r\n  grid-template-rows: repeat(1, 1fr);\r\n\r\n  > div {\r\n    text-align: center;\r\n    color: red;\r\n    font-weight: bold;\r\n  }\r\n`;\r\n\r\nexport default ({\r\n  algorithmGridData,\r\n  counter,\r\n  currentTimer,\r\n  basicGridData,\r\n}: IVisualizerProps) => {\r\n  const [algoTimedData, setAlgoTimedData]: any[] = useState([]);\r\n  // const [queueData, setQueueData]: any[] = useState([]);\r\n  // const [queueTimedData, setQueueTimedData]: any[] = useState([]);\r\n  const processCount = algorithmGridData[0].processCount;\r\n\r\n  let maxGridSize = 0;\r\n\r\n  useEffect(() => {\r\n    // const queueData: any = [];\r\n\r\n    for (let i = 0; i < algorithmGridData.length; i++) {\r\n      if (counter === algorithmGridData[i].startTime) {\r\n        // if (algoTimedData.remainingCPUTime === 0) {\r\n        //   algorithmGridData[i].color = \"green\";\r\n        // }\r\n\r\n        setAlgoTimedData((oldArray: any) => [\r\n          ...oldArray,\r\n          algorithmGridData[i],\r\n        ]);\r\n      }\r\n    }\r\n\r\n    if (counter === maxGridSize) {\r\n      clearInterval(currentTimer);\r\n    }\r\n\r\n    // console.log(counter);\r\n  }, [counter, currentTimer, maxGridSize]);\r\n\r\n  useEffect(() => {\r\n    // const queueData: any = [];\r\n\r\n    setAlgoTimedData([]);\r\n\r\n    // console.log(counter);\r\n  }, [algorithmGridData, basicGridData]);\r\n\r\n  //add up all CPU time to get perfect grid size\r\n  basicGridData.forEach((process: any) => {\r\n    Object.entries(process).forEach(([key, value]: any) => {\r\n      if (key === \"totalCPUTime\") {\r\n        maxGridSize = maxGridSize + value;\r\n      }\r\n    });\r\n  });\r\n\r\n  maxGridSize = maxGridSize + 1;\r\n  return (\r\n    <div>\r\n      <NumberGrid maxGridTime={maxGridSize}>\r\n        {[...Array(maxGridSize)].map((e, key) => (\r\n          <div\r\n            style={{\r\n              border: `2px ${counter > key + 1 ? \"#1B998B\" : \"\"} solid`,\r\n              borderRadius: `${counter > key + 1 ? \"5\" : \"\"}px`,\r\n            }}\r\n            key={key}\r\n          >\r\n            {key + 1}\r\n          </div>\r\n        ))}\r\n      </NumberGrid>\r\n\r\n      <ProcessGrid numOfProcesses={processCount} maxGridTime={maxGridSize}>\r\n        {[...Array(algoTimedData.length)].map((e, key) => (\r\n          <div\r\n            style={{\r\n              gridColumn: `${algoTimedData[key].startTime} / ${algoTimedData[key].endTime}`,\r\n              gridRow: `${algoTimedData[key].line}`,\r\n              border: `1px ${algoTimedData[key].color} solid `,\r\n            }}\r\n            key={key}\r\n          >\r\n            {algoTimedData[key].name}\r\n          </div>\r\n        ))}\r\n      </ProcessGrid>\r\n      {/* \r\n      <NumberGrid maxGridTime={maxGridSize}>\r\n        {[...Array(maxGridSize)].map((e, key) => (\r\n          <div\r\n            style={{\r\n              border: `2px ${counter > key + 1 ? \"#1B998B\" : \"\"} solid`,\r\n              borderRadius: `${counter > key + 1 ? \"5\" : \"\"}px`,\r\n            }}\r\n            key={key}\r\n          >\r\n            {key + 1}\r\n          </div>\r\n        ))}\r\n      </NumberGrid> */}\r\n\r\n      {/* <ProcessGrid numOfProcesses={processCount} maxGridTime={maxGridSize}>\r\n        {[...Array(queueTimedData.length)].map((e, key) => (\r\n          <div\r\n            style={{\r\n              gridColumn: `${queueTimedData[key].startTime} / ${queueTimedData[key].endTime}`,\r\n              gridRow: `${queueTimedData[key].line}`,\r\n            }}\r\n            key={key}\r\n          >\r\n            {queueTimedData[key].name}\r\n          </div>\r\n        ))}\r\n      </ProcessGrid> */}\r\n    </div>\r\n  );\r\n};\r\n","import React, { useEffect, useRef, useState } from \"react\";\r\nimport { FIFO, SJF, SRT, RR, Process, gridData } from \"./utils/Algorithms\";\r\nimport styled, { AnyStyledComponent } from \"styled-components\";\r\nimport Visualizer from \"./components/common/Visualizer\";\r\nimport { Button, Modal, InputNumber, Slider, Timeline } from \"antd\";\r\n\r\nimport \"./App.css\";\r\n// import gridData from \"./utils/initialGridData.json\";\r\n\r\nconst OSApp: AnyStyledComponent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  background-color: #ff9b71;\r\n  font-family: \"KoHo\", sans-serif;\r\n  color: white;\r\n`;\r\nconst VisualizerGroup: AnyStyledComponent = styled.div`\r\n  display: flex;\r\n  justify-content: center;\r\n  background-color: white;\r\n`;\r\n\r\nconst AlgoButton: AnyStyledComponent = styled.button`\r\n  margin: 5px;\r\n  margin-left: 20px;\r\n  margin-right: 20px~;\r\n  background-color: #ff9b71;\r\n  border: none;\r\n  font-size: 20px;\r\n  cursor: pointer;\r\n  &:hover {\r\n    text-decoration: underline solid white;\r\n  }\r\n`;\r\nconst ArrivalProcess: AnyStyledComponent = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n  > h4 {\r\n    flex: 1;\r\n  }\r\n`;\r\nconst CPUTimeProcess: AnyStyledComponent = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n  > h4 {\r\n    flex: 1;\r\n  }\r\n`;\r\nconst NewProcessInputs: AnyStyledComponent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n`;\r\nconst InputGroup: AnyStyledComponent = styled.div`\r\n  width: 1000px;\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-left: auto;\r\n  margin-right: auto;\r\n`;\r\nconst AlgorithmButtons: AnyStyledComponent = styled.div`\r\n  display: inline-block;\r\n  padding: 20px;\r\n`;\r\nconst SliderGroup: AnyStyledComponent = styled.div`\r\n  display: inline-block;\r\n  width: 200px;\r\n  text-align: center;\r\n`;\r\n\r\nfunction App() {\r\n  const [algoData, setAlgoData]: any[] = useState([]);\r\n  const [currentProcesses, setCurrentProcesses]: any[] = useState([]);\r\n  const [counter, setCounter] = useState(0);\r\n  const [arrivalTime, setArrivalTime] = useState(1);\r\n  const [cpuTime, setCPUTime] = useState(1);\r\n  const [timeQuantum, setTimeQuantum] = useState(1);\r\n  const [delay, setDelay] = useState(3);\r\n  const [isModalVisible, setIsModalVisible] = useState(false);\r\n  const timer: any = useRef(null);\r\n\r\n  const instantTimer: any = useRef(null);\r\n  const [instantTimerCounter, setInstantTimerCounter] = useState(0);\r\n  let newProcess: Process;\r\n\r\n  const handleOk = () => {\r\n    newProcess = new Process(\r\n      \"p\" + (currentProcesses.length + 1),\r\n      arrivalTime,\r\n      cpuTime\r\n    );\r\n    setCurrentProcesses((oldProcesses: any) => [...oldProcesses, newProcess]);\r\n    // setIsModalVisible(false);\r\n  };\r\n  const handleCancel = () => {\r\n    setIsModalVisible(false);\r\n  };\r\n  const arrivialInputChange = (value: number) => {\r\n    setArrivalTime(value);\r\n  };\r\n  const cpuInputChange = (value: number) => {\r\n    setCPUTime(value);\r\n  };\r\n  const timeQuantumChange = (value: number) => {\r\n    setTimeQuantum(value);\r\n  };\r\n  const delayChange = (value: number) => {\r\n    setDelay(value);\r\n  };\r\n\r\n  useEffect(() => {\r\n    // useRef value stored in .current property\r\n    timer.current = setInterval(() => setCounter((v) => v + 1), 1000 / delay);\r\n    instantTimer.current = setInterval(\r\n      () => setInstantTimerCounter((v) => v + 1),\r\n      1000\r\n    );\r\n    // clear on component unmount\r\n\r\n    return () => {\r\n      clearInterval(timer.current);\r\n      clearInterval(instantTimer.current);\r\n      setCounter(0);\r\n      setInstantTimerCounter(0);\r\n    };\r\n  }, [algoData, currentProcesses, delay]);\r\n\r\n  const processButtonHandler = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n    event.preventDefault();\r\n\r\n    setIsModalVisible(true);\r\n  };\r\n  const setDataHandler = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n    event.preventDefault();\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      setCurrentProcesses((oldProcesses: any) => [\r\n        ...oldProcesses,\r\n        gridData[i],\r\n      ]);\r\n    }\r\n  };\r\n  const algoButtonHandler = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n    event.preventDefault();\r\n\r\n    const button: HTMLButtonElement = event.currentTarget;\r\n\r\n    switch (button.textContent) {\r\n      case \"FIFO\": {\r\n        setAlgoData(FIFO(currentProcesses));\r\n        setCounter(0);\r\n\r\n        break;\r\n      }\r\n      case \"SJF\": {\r\n        setAlgoData(SJF(currentProcesses));\r\n        setCounter(0);\r\n        break;\r\n      }\r\n      case \"SRT\": {\r\n        setAlgoData(SRT(currentProcesses));\r\n        setCounter(0);\r\n        break;\r\n      }\r\n      case \"RR\": {\r\n        // have to give it a time quantum\r\n        setAlgoData(RR(timeQuantum, currentProcesses));\r\n        setCounter(0);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <OSApp>\r\n      <InputGroup>\r\n        <AlgorithmButtons>\r\n          <Button\r\n            style={{\r\n              margin: \"5px\",\r\n              color: \"#ff9b71\",\r\n              backgroundColor: \"white\",\r\n              fontWeight: \"bold\",\r\n              border: \"none\",\r\n            }}\r\n            type=\"primary\"\r\n            shape=\"round\"\r\n            size=\"large\"\r\n            onClick={processButtonHandler}\r\n          >\r\n            New Process\r\n          </Button>\r\n          <AlgoButton onClick={algoButtonHandler}>FIFO</AlgoButton>\r\n          <AlgoButton onClick={algoButtonHandler}>SJF</AlgoButton>\r\n          <AlgoButton onClick={algoButtonHandler}>SRT</AlgoButton>\r\n          <AlgoButton onClick={algoButtonHandler}>RR</AlgoButton>\r\n          <Button\r\n            style={{ margin: \"10px\" }}\r\n            type=\"dashed\"\r\n            ghost={true}\r\n            shape=\"round\"\r\n            size=\"small\"\r\n            onClick={setDataHandler}\r\n          >\r\n            Set Data\r\n          </Button>\r\n        </AlgorithmButtons>\r\n        <SliderGroup>\r\n          <div style={{ display: \"block\" }}>\r\n            <div style={{ fontSize: \"20px\" }}>Time Quantum</div>\r\n            <Slider\r\n              style={{ margin: \"5px\" }}\r\n              onChange={timeQuantumChange}\r\n              defaultValue={1}\r\n              min={1}\r\n              max={10}\r\n              disabled={false}\r\n            />\r\n          </div>\r\n          <div style={{ display: \"block\" }}>\r\n            <div style={{ fontSize: \"20px\" }}>Visualization Speed</div>\r\n            <Slider\r\n              style={{ margin: \"5px\" }}\r\n              onChange={delayChange}\r\n              defaultValue={3}\r\n              min={1}\r\n              max={5}\r\n              disabled={false}\r\n            />\r\n          </div>\r\n        </SliderGroup>\r\n      </InputGroup>\r\n\r\n      <VisualizerGroup>\r\n        {algoData.length !== 0 ? (\r\n          <Visualizer\r\n            counter={counter}\r\n            currentTimer={timer.current}\r\n            algorithmGridData={algoData}\r\n            basicGridData={currentProcesses}\r\n          />\r\n        ) : (\r\n          <div>Click an algorithm to start!</div>\r\n        )}\r\n      </VisualizerGroup>\r\n\r\n      <Modal\r\n        title=\"Create a new process\"\r\n        visible={isModalVisible}\r\n        onOk={handleOk}\r\n        onCancel={handleCancel}\r\n        width=\"300px\"\r\n        okText=\"Add process\"\r\n        cancelText=\"Done\"\r\n      >\r\n        <NewProcessInputs>\r\n          <ArrivalProcess>\r\n            {\" \"}\r\n            <h4>Arrival Time</h4>\r\n            <InputNumber\r\n              min={1}\r\n              max={10}\r\n              defaultValue={1}\r\n              onChange={arrivialInputChange}\r\n            />\r\n          </ArrivalProcess>\r\n          <CPUTimeProcess>\r\n            {\" \"}\r\n            <h4>Total CPU Time</h4>\r\n            <InputNumber\r\n              min={1}\r\n              max={10}\r\n              defaultValue={1}\r\n              onChange={cpuInputChange}\r\n            />\r\n          </CPUTimeProcess>\r\n        </NewProcessInputs>\r\n\r\n        <Timeline>\r\n          {[...Array(currentProcesses.length)].map((e, key) => (\r\n            <Timeline.Item key={key}>\r\n              <p>{currentProcesses[key].name}</p>\r\n              <p>Arrival Time: {currentProcesses[key].arrivalTime}</p>\r\n              <p>CPU Time: {currentProcesses[key].totalCPUTime}</p>\r\n            </Timeline.Item>\r\n          ))}\r\n        </Timeline>\r\n\r\n        {/* {currentProcesses.length !== 0 ? (\r\n          <Visualizer\r\n            counter={instantTimerCounter}\r\n            currentTimer={instantTimer.current}\r\n            algorithmGridData={currentProcesses}\r\n            basicGridData={currentProcesses}\r\n          />\r\n        ) : (\r\n          <div></div>\r\n        )} */}\r\n      </Modal>\r\n    </OSApp>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}